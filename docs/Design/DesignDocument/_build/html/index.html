<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Welcome to AortaGeomRecon’s design document! &mdash; AortaGeomRecon  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="AortaGeomReconModule" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            AortaGeomRecon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Modules documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">AortaGeomReconModule</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">AortaGeomRecon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Welcome to AortaGeomRecon’s design document!</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="welcome-to-aortageomrecon-s-design-document">
<h1>Welcome to AortaGeomRecon’s design document!<a class="headerlink" href="#welcome-to-aortageomrecon-s-design-document" title="Permalink to this heading"></a></h1>
<p>This is the design document for the AortaGeomRecon module, a <a class="reference internal" href="glossary.html#term-3D-Slicer"><span class="xref std std-term">3D Slicer</span></a> extension to perform <a class="reference internal" href="glossary.html#term-Aorta"><span class="xref std std-term">Aorta</span></a> segmentation and Aorta geometry reconstruction.</p>
<p>You can find the source code, the installation guide, and the user manual in the project’s <a class="reference external" href="https://github.com/smiths/aorta">repository</a>.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>Automatic aorta segmentation in thoracic computed tomography (CT) scans is important for aortic calcification quantification and to guide the segmentation of other central vessels. The work to manually segment regions of interest can be time-consuming and repetitive, and there are some automatic aorta segmentation algorithms posted. This project implemented a semi-automatic algorithm that can extract the 3-dimensional segmentation of the aorta.</p>
</section>
<hr class="docutils" />
<section id="the-steps-before-applying-the-main-algorithm">
<h2>The steps before applying the main algorithm<a class="headerlink" href="#the-steps-before-applying-the-main-algorithm" title="Permalink to this heading"></a></h2>
<p>The algorithm works best with the chest volume cropped to a rectangular prism that contains the aorta and parts of the other organs such as the backbone, blood vessels, and the heart. This can be done with <a class="reference internal" href="glossary.html#term-3D-Slicer"><span class="xref std std-term">3D Slicer</span></a> and its submodule <a class="reference external" href="https://slicer.readthedocs.io/en/latest/user_guide/modules/volumerendering.html">Volume rendering</a>. A detailed guide can be found on the <a class="reference external" href="https://github.com/smiths/aorta#to-use-volume-rendering-to-crop-a-voi">volume rendering and cropping section</a> of the user instructions.</p>
<p>After cropping the volume, which only contains the region of interest, the algorithm needs a set of variables inputs from the user. These variables are:</p>
<ol class="arabic simple">
<li><p>A centre coordinate of <a class="reference internal" href="glossary.html#term-Descending-Aorta"><span class="xref std std-term">Descending Aorta</span></a> and <a class="reference internal" href="glossary.html#term-Ascending-Aorta"><span class="xref std std-term">Ascending Aorta</span></a> located on a <a class="reference internal" href="glossary.html#term-slice"><span class="xref std std-term">slice</span></a> (a voxel).</p></li>
<li><p><a class="reference internal" href="glossary.html#term-Qualified-coefficient"><span class="xref std std-term">Qualified coefficient</span></a></p></li>
<li><p>An integer to indicate the number of slices that the algorithm is allowed to skip consecutively.</p></li>
</ol>
</section>
<section id="the-main-ideas-of-the-algorithm">
<h2>The main ideas of the algorithm<a class="headerlink" href="#the-main-ideas-of-the-algorithm" title="Permalink to this heading"></a></h2>
<p>At the beginning of the algorithm, the user inputs the integer coordinates indicating the position of the descending aorta or ascending aorta centre on a single <a class="reference internal" href="glossary.html#term-slice"><span class="xref std std-term">slice</span></a>. The algorithm works separately on the descending aorta segmentation and the ascending aorta segmentation. Thus, it will ask users to input the coordinate of the descending aorta centre. After completing this segmentation, it will prompt the user for the input variable of the ascending aorta.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The user’s chosen slice will be used as a reference throughout the workflow of the algorithm. Therefore, changing the input of the centre coordinates on a different slice could generate a slightly different segmentation result.</p>
</div>
<p>This algorithm segments each <a class="reference internal" href="glossary.html#term-slice"><span class="xref std std-term">slice</span></a> with <a class="reference external" href="https://simpleitk.org/doxygen/latest/html/classitk_1_1simple_1_1ThresholdSegmentationLevelSetImageFilter.html">SITK::ThresholdSegmentationLevelSetImageFilter</a>. The principles of this image filter can be explained with two terms: <a class="reference internal" href="glossary.html#term-Level-sets"><span class="xref std std-term">Level sets</span></a> segmentation method, and a <a class="reference internal" href="glossary.html#term-threshold"><span class="xref std std-term">threshold</span></a> range that defines the intensity of the acceptable pixel. The following steps elaborate on how the algorithm calculated the necessary values to perform segmentation.</p>
<p>For each slice starting from the user’s selected slice, going in the <a class="reference internal" href="glossary.html#term-inferior"><span class="xref std std-term">inferior</span></a> first, then <a class="reference internal" href="glossary.html#term-superior"><span class="xref std std-term">superior</span></a> direction:</p>
<ol class="arabic">
<li><p>With <a class="reference external" href="https://simpleitk.org/doxygen/latest/html/classitk_1_1simple_1_1BinaryDilateImageFilter.html">SITK::BinaryDilateImageFilter</a> to perform <a class="reference internal" href="glossary.html#term-binary-dilation"><span class="xref std std-term">binary dilation</span></a>, the algorithm generates a <a class="reference internal" href="glossary.html#term-label-map"><span class="xref std std-term">label map</span></a> image which contains a circle-like shape around the centre coordinate (user input’s or calculated by the algorithm). Each pixel within the circle will be labeled as a white pixel (value of 1), and the rest of the pixels are labeled as black pixels (value of 0).</p></li>
<li><p>With <a class="reference external" href="https://simpleitk.org/doxygen/latest/html/classitk_1_1simple_1_1SignedMaurerDistanceMapImageFilter.html">SITK::SignedMaurerDistanceMapImageFilter</a>, the algorithm creates another image, the <a class="reference internal" href="glossary.html#term-Euclidean-distance-transform"><span class="xref std std-term">Euclidean distance transform</span></a> of the label image. This is used as a <a class="reference internal" href="glossary.html#term-contour-line"><span class="xref std std-term">contour line</span></a> that helps build the gradient mentioned in <a class="reference internal" href="glossary.html#term-Level-sets"><span class="xref std std-term">Level sets</span></a>.</p></li>
<li><p>By using <a class="reference external" href="https://simpleitk.org/doxygen/latest/html/classitk_1_1simple_1_1LabelStatisticsImageFilter.html">SITK::LabelStatisticsImageFilter</a>, the algorithm gets the mean and the standard deviation of the intensity values of the pixels that were labeled as the white pixel in the previous step. The algorithm uses <a class="reference internal" href="glossary.html#term-threshold-coefficient"><span class="xref std std-term">threshold coefficient</span></a> to calculate the lower and upper <a class="reference internal" href="glossary.html#term-threshold"><span class="xref std std-term">threshold</span></a> to be used in the next step.</p></li>
<li><p>With <a class="reference external" href="https://simpleitk.org/doxygen/latest/html/classitk_1_1simple_1_1ThresholdSegmentationLevelSetImageFilter.html">SITK::ThresholdSegmentationLevelSetImageFilter</a>,  the seed image calculated in step 2, and the lower and upper threshold value calculated in step 3, the algorithm performs segmentation and generated a <a class="reference internal" href="glossary.html#term-segmented-slice"><span class="xref std std-term">segmented slice</span></a>.</p></li>
<li><p>The algorithm determines whether to accept the <a class="reference internal" href="glossary.html#term-segmented-slice"><span class="xref std std-term">segmented slice</span></a> or not, based on the number of white pixels on the segmented slice, and the <a class="reference internal" href="glossary.html#term-Qualified-coefficient"><span class="xref std std-term">Qualified coefficient</span></a> to control the limit.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>To determine whether a segmented slice is acceptable, different conditions are verified for <a class="reference internal" href="glossary.html#term-Descending-Aorta"><span class="xref std std-term">Descending Aorta</span></a> and <a class="reference internal" href="glossary.html#term-Ascending-Aorta"><span class="xref std std-term">Ascending Aorta</span></a>. These conditions check are all involved with the <a class="reference internal" href="glossary.html#term-Qualified-coefficient"><span class="xref std std-term">Qualified coefficient</span></a>, which is decided by the user. In simple terms, the larger the <a class="reference internal" href="glossary.html#term-Qualified-coefficient"><span class="xref std std-term">Qualified coefficient</span></a>, the looser the condition on accepting a segmented slice.</p>
</div>
</div></blockquote>
</li>
<li><p>If the algorithm accepted this segmented slice, a new centre coordinate is calculated and used as the seed coordinate for segmenting the next slice.</p></li>
<li><p>When a segmented slice is not acceptable, the algorithm will skip this slice if the number of consecutive skipped slices is less than the user’s limit. Otherwise, the algorithm will stop the segmentation loop.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>The algorithm will replace these skipped slices with the calculated intersection of the previous and the next slice.</p>
</div>
</div></blockquote>
</li>
</ol>
</section>
<section id="the-simplified-version-of-the-algorithm">
<h2>The simplified version of the algorithm<a class="headerlink" href="#the-simplified-version-of-the-algorithm" title="Permalink to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">  2</span><span class="sd">inputs to the program</span>
<span class="linenos">  3</span><span class="sd">   cropped_image: n-dimensional array with a shape of (x, y, z)</span>
<span class="linenos">  4</span><span class="sd">   seed_aorta_centre: tuple (int, int)</span>
<span class="linenos">  5</span><span class="sd">   seed_slice_index: int</span>
<span class="linenos">  6</span><span class="sd">   qualified_coefficient: float</span>
<span class="linenos">  7</span><span class="sd">   num_skipped_slice: int</span>
<span class="linenos">  8</span>
<span class="linenos">  9</span><span class="sd">outputs:</span>
<span class="linenos"> 10</span><span class="sd">   processing_image: n-dimensional array with a shape of (x, y, z) with segmented volume</span>
<span class="linenos"> 11</span>
<span class="linenos"> 12</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 13</span><span class="n">processing_image</span> <span class="o">=</span> <span class="n">cropped_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="linenos"> 14</span><span class="n">white_pixel</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos"> 15</span><span class="n">black_pixel</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 16</span><span class="n">skip_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 17</span><span class="n">segment_filter</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ThresholdSegmentationLevelSetImageFilter</span><span class="p">()</span>
<span class="linenos"> 18</span><span class="n">skipped_slice</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 19</span>
<span class="linenos"> 20</span><span class="c1"># The statistics of the user&#39;s chosen slice will be used as reference</span>
<span class="linenos"> 21</span><span class="c1"># to determine whether a new segmented slice is acceptable</span>
<span class="linenos"> 22</span><span class="n">segmented_slice</span> <span class="o">=</span> <span class="n">segment_single_slice</span><span class="p">(</span><span class="n">seed_slice_index</span><span class="p">,</span> <span class="n">seed_aorta_centre</span><span class="p">)</span>
<span class="linenos"> 23</span>
<span class="linenos"> 24</span><span class="c1"># Any pixel with positive intensity value will be set to white_pixel</span>
<span class="linenos"> 25</span><span class="n">new_slice</span> <span class="o">=</span> <span class="n">Array</span><span class="p">[</span><span class="n">segmented_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">][</span><span class="n">segmented_slice</span><span class="o">.</span><span class="n">length</span><span class="p">]</span>
<span class="linenos"> 26</span><span class="k">for</span> <span class="n">x</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">segmented_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
<span class="linenos"> 27</span>   <span class="k">for</span> <span class="n">y</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">segmented_slice</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
<span class="linenos"> 28</span>      <span class="k">if</span> <span class="n">segmented_slice</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">black_pixel</span><span class="p">:</span>
<span class="linenos"> 29</span>         <span class="n">new_slice</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">white_pixel</span>
<span class="linenos"> 30</span>      <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 31</span>         <span class="n">new_slice</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">black_pixel</span>
<span class="linenos"> 32</span>
<span class="linenos"> 33</span><span class="c1"># orginal_size will be used to compare new slice&#39;s size</span>
<span class="linenos"> 34</span><span class="c1"># to determine if the new slice is acceptable</span>
<span class="linenos"> 35</span><span class="n">original_size</span><span class="p">,</span> <span class="n">prev_centre</span> <span class="o">=</span> <span class="n">count_pixels</span><span class="p">(</span><span class="n">new_slice</span><span class="p">)</span>
<span class="linenos"> 36</span><span class="n">prev_size</span> <span class="o">=</span> <span class="n">original_size</span>
<span class="linenos"> 37</span>
<span class="linenos"> 38</span><span class="c1"># Repeat the above process for each slice</span>
<span class="linenos"> 39</span><span class="k">for</span> <span class="n">slice_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
<span class="linenos"> 40</span>    <span class="c1"># prev_centre is the new derived centre from last segmented slice</span>
<span class="linenos"> 41</span>    <span class="n">segmented_slice</span> <span class="o">=</span> <span class="n">segment_single_slice</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">prev_centre</span><span class="p">)</span>
<span class="linenos"> 42</span>
<span class="linenos"> 43</span>    <span class="c1"># element-wise operation</span>
<span class="linenos"> 44</span>    <span class="c1"># exactly what we doing with the double for-loop</span>
<span class="linenos"> 45</span>    <span class="c1"># to assign white pixel and black pixel</span>
<span class="linenos"> 46</span>    <span class="n">new_slice</span> <span class="o">=</span> <span class="n">segmented_slice</span> <span class="o">&gt;</span> <span class="n">black_pixel</span>
<span class="linenos"> 47</span>
<span class="linenos"> 48</span>    <span class="n">total_coord</span><span class="p">,</span> <span class="n">centre</span> <span class="o">=</span> <span class="n">count_pixels</span><span class="p">(</span><span class="n">new_slice</span><span class="p">)</span>
<span class="linenos"> 49</span>    <span class="k">if</span> <span class="n">is_new_slice_qualified</span><span class="p">(</span><span class="n">total_coord</span><span class="p">):</span>
<span class="linenos"> 50</span>       <span class="n">skip_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 51</span>       <span class="c1"># processing_image is the segmented volume returned</span>
<span class="linenos"> 52</span>       <span class="n">processing_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">slice_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_slice</span>
<span class="linenos"> 53</span>       <span class="n">prev_centre</span> <span class="o">=</span> <span class="n">centre</span>
<span class="linenos"> 54</span>       <span class="n">prev_size</span> <span class="o">=</span> <span class="n">total_coord</span>
<span class="linenos"> 55</span>       <span class="c1"># for ascending aorta, we will generate more possible coordinates</span>
<span class="linenos"> 56</span>       <span class="c1"># and use it in segmentation algorithm</span>
<span class="linenos"> 57</span>       <span class="c1"># prev_seeds = seeds</span>
<span class="linenos"> 58</span>    <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 59</span>       <span class="n">skipped_slice</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="p">)</span>
<span class="linenos"> 60</span>       <span class="n">skip_counter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="linenos"> 61</span>       <span class="k">if</span> <span class="n">skip_counter</span> <span class="o">==</span> <span class="n">num_skipped_slice</span><span class="p">:</span>
<span class="linenos"> 62</span>           <span class="k">break</span>
<span class="linenos"> 63</span>
<span class="linenos"> 64</span><span class="k">for</span> <span class="n">slice_i</span> <span class="ow">in</span> <span class="n">skipped_slice</span><span class="p">:</span>
<span class="linenos"> 65</span>    <span class="c1"># replace processing_image[slice_i] with the intersection of its previous and next slice</span>
<span class="linenos"> 66</span>
<span class="linenos"> 67</span><span class="k">return</span> <span class="n">processing_image</span>
<span class="linenos"> 68</span>
<span class="linenos"> 69</span><span class="k">def</span> <span class="nf">generate_label_map</span><span class="p">(</span><span class="n">curr_slice</span><span class="p">,</span> <span class="n">prev_centre</span><span class="p">):</span>
<span class="linenos"> 70</span>   <span class="c1"># Create a label map based on the centre coordinate</span>
<span class="linenos"> 71</span>   <span class="c1"># sitk.BinaryDilate populate a circle-liked shape where pixel in the circle is marked as 1</span>
<span class="linenos"> 72</span>   <span class="n">label_map</span> <span class="o">=</span> <span class="n">curr_slice</span><span class="o">.</span><span class="n">copy_size</span><span class="p">()</span>
<span class="linenos"> 73</span>   <span class="n">spacing</span> <span class="o">=</span> <span class="mi">3</span>
<span class="linenos"> 74</span>   <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">do</span><span class="p">:</span>
<span class="linenos"> 75</span>      <span class="n">circle_x</span> <span class="o">=</span> <span class="n">prev_centre</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spacing</span><span class="o">*</span><span class="n">i</span>
<span class="linenos"> 76</span>      <span class="n">label_map</span><span class="p">[(</span><span class="n">circle_x</span><span class="p">,</span> <span class="n">prev_centre</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">white_pixel</span>
<span class="linenos"> 77</span>   <span class="n">label_map</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">BinaryDilate</span><span class="p">(</span><span class="n">label_map</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos"> 78</span>   <span class="k">return</span> <span class="n">label_map</span>
<span class="linenos"> 79</span>
<span class="linenos"> 80</span><span class="k">def</span> <span class="nf">segment_single_slice</span><span class="p">(</span><span class="n">current_index</span><span class="p">,</span> <span class="n">prev_centre</span><span class="p">):</span>
<span class="linenos"> 81</span>   <span class="c1"># retrieve the 2d slice to be processed</span>
<span class="linenos"> 82</span>   <span class="n">curr_slice</span> <span class="o">=</span> <span class="n">cropped_image</span><span class="p">[:,:,</span> <span class="n">current_index</span><span class="p">]</span>
<span class="linenos"> 83</span>   <span class="c1"># create a label map</span>
<span class="linenos"> 84</span>   <span class="n">label_map</span> <span class="o">=</span> <span class="n">generate_label_map</span><span class="p">(</span><span class="n">curr_slice</span><span class="p">,</span> <span class="n">prev_centre</span><span class="p">)</span>
<span class="linenos"> 85</span>   <span class="c1"># Calculate statistics associated with white_pixel label</span>
<span class="linenos"> 86</span>   <span class="n">stats</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">LabelStatisticsImageFilter</span><span class="p">()</span>
<span class="linenos"> 87</span>   <span class="n">stats</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">curr_slice</span><span class="p">,</span> <span class="n">label_map</span><span class="p">)</span>
<span class="linenos"> 88</span>   <span class="c1"># Threshold for SITK::ThresholdSegmentationLevelSetImageFilter</span>
<span class="linenos"> 89</span>   <span class="c1"># stats.GetMean(white_pixel) returns the mean intensity values of the pixels labeled white pixels.</span>
<span class="linenos"> 90</span>   <span class="n">lower_threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">GetMean</span><span class="p">(</span><span class="n">white_pixel</span><span class="p">)</span> <span class="o">-</span> <span class="n">threshold_coef</span><span class="o">*</span><span class="n">stats</span><span class="o">.</span><span class="n">GetSigma</span><span class="p">(</span><span class="n">white_pixel</span><span class="p">))</span>
<span class="linenos"> 91</span>   <span class="n">upper_threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">GetMean</span><span class="p">(</span><span class="n">white_pixel</span><span class="p">)</span> <span class="o">+</span> <span class="n">threshold_coef</span><span class="o">*</span><span class="n">stats</span><span class="o">.</span><span class="n">GetSigma</span><span class="p">(</span><span class="n">white_pixel</span><span class="p">))</span>
<span class="linenos"> 92</span>   <span class="c1"># calculate the Euclidean distance transform and use it to perform segmentation</span>
<span class="linenos"> 93</span>   <span class="n">dis_map</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">SignedMaurerDistanceMap</span><span class="p">(</span><span class="n">label_map</span><span class="p">)</span>
<span class="linenos"> 94</span>   <span class="n">segment_filter</span><span class="o">.</span><span class="n">SetLowerThreshold</span><span class="p">(</span><span class="n">lower_threshold</span><span class="p">)</span>
<span class="linenos"> 95</span>   <span class="n">segment_filter</span><span class="o">.</span><span class="n">SetUpperThreshold</span><span class="p">(</span><span class="n">upper_threshold</span><span class="p">)</span>
<span class="linenos"> 96</span>   <span class="c1"># Segmentated slice, a ndarrays of shape (x, y)</span>
<span class="linenos"> 97</span>   <span class="k">return</span> <span class="n">segment_filter</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">dis_map</span><span class="p">,</span> <span class="n">curr_slice</span><span class="p">)</span>
<span class="linenos"> 98</span>
<span class="linenos"> 99</span><span class="k">def</span> <span class="nf">count_pixels</span><span class="p">(</span><span class="n">segmented_slice</span><span class="p">):</span>
<span class="linenos">100</span>   <span class="c1"># This function will count the number of white pixels in this segmented slice</span>
<span class="linenos">101</span>   <span class="c1"># and calculate a new centre based on the result</span>
<span class="linenos">102</span>   <span class="n">num_of_white_pixel</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos">103</span>   <span class="n">x_coord</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos">104</span>   <span class="n">y_coord</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos">105</span>   <span class="k">for</span> <span class="n">x</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">segmented_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
<span class="linenos">106</span>      <span class="k">for</span> <span class="n">y</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">segmented_slice</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
<span class="linenos">107</span>         <span class="k">if</span> <span class="n">segmented_slice</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="n">white_pixel</span><span class="p">:</span>
<span class="linenos">108</span>            <span class="n">x_coord</span> <span class="o">+=</span> <span class="n">x</span>
<span class="linenos">109</span>            <span class="n">y_coord</span> <span class="o">+=</span> <span class="n">y</span>
<span class="linenos">110</span>            <span class="n">num_of_white_pixel</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="linenos">111</span>   <span class="n">new_centre</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_coord</span><span class="o">/</span><span class="n">num_of_white_pixel</span><span class="p">,</span> <span class="n">y_coord</span><span class="o">/</span><span class="n">num_of_white_pixel</span><span class="p">)</span>
<span class="linenos">112</span>   <span class="k">return</span> <span class="n">num_of_white_pixel</span><span class="p">,</span> <span class="n">new_centre</span>
<span class="linenos">113</span>
<span class="linenos">114</span><span class="k">def</span> <span class="nf">is_new_slice_qualified</span><span class="p">(</span><span class="n">new_size</span><span class="p">):</span>
<span class="linenos">115</span>   <span class="c1"># compare new slice&#39;s number of white pixel to</span>
<span class="linenos">116</span>   <span class="c1"># the original slice and the previous size</span>
<span class="linenos">117</span>
<span class="linenos">118</span>   <span class="n">condition_1</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&lt;</span> <span class="n">original_size</span><span class="o">*</span><span class="n">qualified_coefficient</span>
<span class="linenos">119</span>   <span class="n">condition_2</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">original_size</span><span class="o">/</span><span class="n">qualified_coefficient</span>
<span class="linenos">120</span>   <span class="n">condition_3</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&lt;</span> <span class="n">prev_size</span><span class="o">*</span><span class="n">qualified_coefficient</span>
<span class="linenos">121</span>
<span class="linenos">122</span>   <span class="k">return</span> <span class="n">condition_1</span> <span class="ow">and</span> <span class="n">condition_2</span> <span class="ow">and</span> <span class="n">condition_3</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can find the definitions of each function within the module below</p>
</div>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Modules documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">AortaGeomReconModule</a><ul>
<li class="toctree-l2"><a class="reference internal" href="AortaGeomReconDisplayModuleLib.html">AortaGeomReconDisplayModuleLib package</a></li>
<li class="toctree-l2"><a class="reference internal" href="test.html">test package</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this heading"></a></h2>
<div class="line-block">
<div class="line"><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></div>
<div class="line"><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></div>
</div>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-right" title="AortaGeomReconModule" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Jingyi Lin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>