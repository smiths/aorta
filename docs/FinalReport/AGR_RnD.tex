\chapter{AortaGeomRecon Research and Development}
This chapter will discuss about the research and development of the \progname{}. \\
AortaGeomRecon stands for Aorta Geometry Reconstruction. The main objective of this software is to semi-automatically build 3D geometry of the Aorta from the patient's chest ct scans.  The existing methods are often involved of extensive manual works by using a software with many steps. An experienced user, who might be a medical domain expert, needs to do a minimum of 10 minutes of manual works. \\
The implementation till the date of this report can let the users who have the user characteristics described in SRS \citep{SRS} get the Aorta 3D geometry with only a few hyperparameters which can be set within half a minute, and the result requires maximum 2 minutes of execution time. \\


\section{Existing Methods}
There are many segmentation software available to the users, we will discuss the two main methods on two softwares.

\subsection{ITK-Snap bubble method} 
\indent
ITK-Snap provides a segmentation method that first let user to select multiple voxels with a custom intial size and expanding size within any volume. We refer this method as ``bubble method''.

Through many iterations, the voxels expand to fill the entire volume, finally user will need to cut the extra part of the volume. This Figure~\ref{fig_ITK} shows the ITK-Snap UI executing the segmentation.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.65\textwidth]{figures/Sample/ITK-Bubble-method.png}
    \caption[ITK-Snap's Bubble segmentation UI]{ITK-Snap's Bubble segmentation method}
    \label{fig_ITK}
\end{figure}

The advantages of the bubble method is that it guarantes to produce a correct the segmentation result. A medical domain expert can manually control the wanted area, and visually observing the segmentation result expanding, shrinking and the user can erase the unwanted part.

The disadvantages of this method is that the operations described above are complicated. Eeasier to say then do, an opeartor who has previous experience building the geometry with this method still needed 20 minutes of manual work building a new aorta geometry. Plus, ITK-Snap software can only read VTK file, therefore the chest CT scans are usually DICOM needed a manual conversion before using this software and its segmentation method.

\subsection{3D Slicer intensity interval segmentation}
3D Slicer is another well-known medical image processing software for academic. 3D Slicer provides multiple segmentation methods, and one of the quickiest and easiest to use is the intensity based segmentation.

This method first let user select a small area that belongs to the wanted area on a 2D plane (Axial, Sagittal, and Coronal). 3D Slicer read the pixels' intensity of the surrounding area, and segment based on the intensity. Any pixels's intensity that is within the range will be segmented as the segmentation result. 

Like the bubble method, this method often reads extra volume, and requires user to cut the unwanted parts. A Youtube video shows an experience user who gets the aorta 3D geometry with 10 minutes of manual works.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/Sample/3D-Slicer-Segmentation.png}
    \caption[3D Slicer BuiltIn Segmentation UI]{3D Slicer BuiltIn Segmentation Method}
    \label{fig_3D_Seg_Builtin}
\end{figure}

\section{Segmentation Algorithm}

This section introduces the key concepts of the implementation on the segmentation algorithm. The algorithm is developed in Python, by using external libraries including SimpleITK and Numpy. 

\subsection{Background}

SimpleITK is an open-source multi-dimensional image analysis library Developed by the Insight Toolkit community for the biomedical sciences and beyond. NumPy is the fundamental package for scientific computing with Python, especially for the performance on multi-dimensional array processing. The algorithm will use functions from these two libraries for image processing and multi-dimensional array processing.

The algorithm works best with the chest volume cropped to a rectangular prism that contains the aorta and parts of the other organs such as the backbone, blood vessels, and the heart. This can be done with 3D Slicer and its builtIn modules, Volume rendering and Crop Volume.

At the beginning of the algorithm, the user inputs two integer coordinates indicating the position of the descending aorta and ascending aorta centre on a single slice. This algorithm segments each slice with SITK::ThresholdSegmentationLevelSetImageFilter. The principles of this image filter can be explained with two terms: Level sets segmentation method, and a threshold range that defines the intensity of the acceptable pixel. The following steps elaborate on how the algorithm calculated the necessary values to perform segmentation.

For each slice starting from the user’s selected slice, going in the inferior first, then superior direction:

\subsection{Algorithm Overview}

\subsubsection{Label Map}
The algorithm uses SITK::BinaryDilateImageFilter to perform binary dilation to generate a circle-like shape around the centre coordinates (user input’s or calculated by the algorithm). Each pixel within this shape will be labeled as a white pixel (value of 1), and the rest of the pixels are labeled as black pixels (value of 0). The generated result is the label map image, and we will use it in the next few steps. The size of the circle-like shape is determined by the kernel size.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/AortaGeomRecon/label_image.png}
    \caption[A label image]{A label image}
    \label{fig_label_image}
\end{figure}

\subsubsection{Distance Map}
With SITK::SignedMaurerDistanceMapImageFilter, the algorithm creates another image, the Euclidean distance transform of the label image. This is used as a contour line that helps build the gradient mentioned in Level sets.

\subsubsection{Calculate a threshold range}
By using SITK::LabelStatisticsImageFilter, the algorithm gets the mean and the standard deviation of the intensity values of the pixels that were labeled as the white pixel in the previous step. The algorithm uses threshold coefficient to calculate the lower and upper threshold to be used in the next step.

\subsubsection{Segment a single slice}
With SITK::ThresholdSegmentationLevelSetImageFilter, the seed image calculated in step 2, and the lower and upper threshold value calculated in step 3, the algorithm performs segmentation and generated a segmented slice.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/AortaGeomRecon/segment_label_image.png}
    \caption[A segmented image]{A segmented image}
    \label{fig_segmented_image}
\end{figure}

\subsubsection{Calculate new centroids}
By comparing each pixel segmented as aorta to the previous descending centroid and the previous ascending centroid, the algorithm use the positions of the points closer to the previous descending centroid to calculate new descending aorta centroid, and vice-versa for the ascending aorta centroid. However, at certain point during the segmentation in inferior direciton, the slice might reaches the end of the ascending aorta, where the voxels belong to the part of the heart. The algorithm will stop using ascending aorta centroid and only computes descending aorta centroid for the slices afterward.

\subsection{Parameters}
The main parameters inputs from the users are:
\begin{itemize}
\item The centre coordinates of Descending Aorta and Ascending Aorta locate on the same axial plane
\item The stop limit which controls the stop condition
\item The threshold coefficient which controls the segmentation acceptable intensity range
\item The kernel size which controls the init size 
\item The threshold Segmentation Level Sets Image Filter parameters, including:
\begin{itemize}
\item The rms error
\item The maximum iteration
\item The curvature scaling
\item The propagation scaling
\end{itemize}
\end{itemize}




\section{3D Slicer Extension Development}
The project has started with the a simple segmentation algoritm build on the jupyter notebook. When getting a new patient's data, the user will need to investigate the chest ct scans using another software (3D Slicer, ITK-Snap), to get the readings of the starting voxel and the size crop the volume, and get the index of the aorta seed. This Figure~\ref{fig_aorta_seed} shows an example of the aorta seeds.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/Sample/Aorta_seeds.png}
    \caption[The Aorta Seeds]{The aorta seeds \citep{6346433}}
    \label{fig_aorta_seed}
\end{figure}

To improve the usability of the \progname{} (reduce the amount of time for user inputs and execution), we implemented an extension module on 3D Slicer. 

3D Slicer is a open-sourced medical image processing software for research. 3D Slicer provides useful modules such as Crop Volume module and Volume Rendering module, and it's highly modulizable with Python Scripting to control the extension module sequence, and QT designer to generate Graphical User Interface.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{figures/Sample/SlicerUI.png}
    \caption[AortaGeomRecon phase 1 User Interface]{AortaGeomRecon UI phase 1}
    \label{fig_UI_1}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{figures/Sample/SlicerUI_2.png}
    \caption[AortaGeomRecon phase 2 User Interface]{AortaGeomRecon UI phase 2}
    \label{fig_UI_2}
\end{figure}

3D Slicer supports modulization with an extension. An extension is a software bundle that includes every modules to solve a specific medical image problem. An extension can compose multiple module, where each module is dedicated to solve a sub-problem.

%\begin{itemize}
%\item 3D Slicer Data Structure \\ 

\subsection{3D Slicer's data structure}

3D Slicer's Data Structure can be divided into two categories: Node for storing large data such as DICOM with a Volume Node, Volume rendering Region of Interest Node, Label Map Volume Node, and parameters are read from extension's module UI and are stored as string. Every data stored in 3D Slicer can be accessed by the 3D Slicer's Widget Class and Logic Class for further processing.

On a higher level, 3D Slicer stores all the above data in a scene object. 3D Slicer can load any MRMLscene file, this allowed user to retrieve all the data nodes and parameters. On the other hand, 3D Slicer has a special input module, the DICOM database allowed user to store DICOM metadata in 3D Slicer.

\subsection{3D Slicer's scripted module}

Every ScriptLoadableModule in 3D Slicer have a Widget Class and a Logic Class. The Widget Class is used to initialize the extension module's UI component, and the parameters tied to the UI compoenent. The module's Logic Class is used to perform the processing of the data. In the Logic Class, we initialize an AortaGeomRecon Segmenter object with the attributes set to the parameters reading from UI component, which are inputs by the user. After completing the segmentation with Segmenter object, we convert the SimpleITK image object to a volume node corresponding in 3D Slicer, which allow the user to visualize the segmentation result. 

\section{GitHub and Workflows}
This project uses GitHub for version control. \\
GitHub issues tracker use to keep track the items to work on throughout the development of the project\\
GitHub Project is used for dividing a large issue into smaller tasks, expected date of the completion. This is useful for project management.\\
GitHub Workflow is a great tool for Continuous Integration tests. \\
We uses GitHub Workflow for Linter and Continuous Integration tests. 

%\end{itemize}


%\begin{itemize}
%\item Inputs Parameter


%\item Threshold
%\item LevelSets
%\item Stop Condition
%\end{itemize}
%This is a sample chapter
%
%If you need to use quotes, type it ``like this''.


%\section{Referencing}
%These are some sample references to GAMYGDALA~\citep{popescu2014gamygdala} from 
%the \texttt{references.bib} file and state effects of 
%cognition~\citep{hudlicka2002time} from the \texttt{references\_another.bib} 
%file. These references are not in the same .bib file.
%
%\section{Figures}
%This is a single image figure (Figure~\ref{fig_singleenv}):
%
%\begin{figure}[ht]
%    \centering
%    \includegraphics[width=0.6\textwidth]{figures/Sample/tumblr_static_eaceks0rfxsss8o4swscw40wo.jpg}
%    \caption[Single Figure Environment Listed Title]{This is a single figure 
%    environment}
%    \label{fig_singleenv}
%\end{figure}
%
%This is a multi-image figure with a top (Figure~\ref{fig_multienv_1}) and bottom (Figure~\ref{fig_multienv_2}) aligned subfigures:
%
%\begin{figure}[ht]
%	\centering
%	\begin{subfigure}[t]{\textwidth}
%		\centering
%		
%\includegraphics[width=0.7\textwidth]{figures/Sample/tumblr_static_eaceks0rfxsss8o4swscw40wo.jpg}
%		\caption{Figure 1}
%		\label{fig_multienv_1}
%	\end{subfigure}
%	~
%	\begin{subfigure}[t]{\textwidth}
%		\centering
%		
%\includegraphics[width=0.7\textwidth]{figures/Sample/tumblr_static_eaceks0rfxsss8o4swscw40wo.jpg}
%		\caption{Figure 2}
%		\label{fig_multienv_2}
%	\end{subfigure}
%	
%	\caption{A Multi-Figure Environment}
%	\label{fig_multienv}
%\end{figure}
%
%\section{Tables}
%
%Here is a sample table (Table~\ref{tab_sample}):
%
%	\begin{table}[ht]
%	\centering
%	\begin{tabular}{ m{0.2\textwidth} m {0.1\textwidth} m{0.15\textwidth} }
%		\toprule
%		A & $\longleftrightarrow$ & B \\
%		C & $\longleftrightarrow$ & D \\
%		\bottomrule	
%	\end{tabular}	
%	\caption{A sample table}	
%	\label{tab_sample}
%\end{table}
%
%\subsection{Long Tables}
%A sample long table is shown in Appendix~\ref{appendix_b}.
%
%\section{Equations}
%
%Here is a sample equation (Equation~\ref{eq_lineslope}):
%
%\begin{equation} \label{eq_lineslope}
%	y = mx + b
%\end{equation}